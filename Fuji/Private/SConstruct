# This is a build file for "SCons" (http://www.scons.org/), a python based 
# build tool
#
# It allows the project to be built on Unix/Linux, and may be able to provide
# an alternative build system for win32 in the future.


import glob
import string
import sys
import os
import string
import re

CC = 'gcc'
CXX = 'g++'
BASENAME = 'Fuji'
CPPPATH = ['Include'] # Include files
SOURCEDIRS = ['Source']
MASKEDFILES = ['Source/MFGadgets.cpp']
BINDIR = 'Bin'
CCFLAGS = '-Wall -Wno-unknown-pragmas -pipe'


# Find out what platform we're building on, and set the platform specific options for it
platform = str(ARGUMENTS.get('OS', Platform()))
if(platform == 'posix'):
	platform = 'linux'

if(platform == 'linux'): # It should be possible to use scons on Windows too
	SOURCEDIRS.append('Linux')
	CPPPATH.append('/usr/X11R6/include')
	CCFLAGS += ' -D_LINUX'
elif(platform == 'DC'):
	SOURCEDIRS.append('DC')
	CPPPATH.append('DC')
	CPPPATH.append('DC/kos-1.2.0/include')
	CPPPATH.append('DC/kos-1.2.0/libc/include')
	CPPPATH.append('DC/kos-1.2.0/kernel/arch/dreamcast/include')
	CCFLAGS += ' -D_DC'

	CC = 'sh-elf-gcc'
	CXX = 'sh-elf-g++'
elif(platform == 'PS2'):
	SOURCEDIRS.append('PS2')
	CPPPATH.append('PS2')
	CCFLAGS += ' -D_PS2'

	CC = 'ee-elf-gcc'
	CXX = 'ee-elf-g++'
elif(platform == 'GCN'):
	SOURCEDIRS.append('GCN')
	CPPPATH.append('GCN')
	CCFLAGS += ' -D_GCN'

	CC = 'ppc-elf-gcc'
	CXX = 'ppc-elf-g++'
else:
	sys.stderr.write('Platform unsupported (use OS=linux|DC|PS2|GCN) [%s]\n' % (platform,))
	sys.exit(0)


# Deal with the command line options
build_type = ARGUMENTS.get('BUILD_TYPE', 'DEBUG')
build_type = string.upper(build_type)

if(build_type == 'DEBUG'):
	CCFLAGS += ' -D_DEBUG -g'
elif(build_type == 'RELEASE'):
	CCFLAGS += ' -D_RELEASE -O3'
elif(build_type == 'RETAIL'):
	CCFLAGS += ' -D_RETAIL -O3'
else:
	sys.stderr.write('Invalid build type, use one of: BUILD_TYPE=(DEBUG|RELEASE|RETAIL)\n')
	sys.exit(0)

# Processor tuning
processor = ARGUMENTS.get('PROCESSOR')
if(processor != None):
	CCFLAGS += ' -mcpu=' + str(processor)

# C compiler to use
cc = ARGUMENTS.get('CC')
if(cc != None):
	CC = str(cc)

# C++ compiler to use
cxx = ARGUMENTS.get('CXX')
if(cxx != None):
	CXX = str(cxx)


# Get the full list of all the source files
sources = [] # Empty list to start with
build_sources = []
for dir in SOURCEDIRS:
	sources = sources + glob.glob(dir + '/*.cpp')

new_sources = []

# Remove any masked files
for source in sources:
	is_masked = 0

	sys.stderr.write(source + '\n')
	source = re.sub('\\\\', '/', source) #

	for masked in MASKEDFILES:
		if(masked == source):
			is_masked = 1

	if(not is_masked):
		new_sources.append(source)

sources = new_sources

env = Environment(CCFLAGS = CCFLAGS, CPPPATH = CPPPATH, ENV = os.environ, tools=['mingw'])

# Optional options
if(CC != None):
	env['CC'] = CC

if(CXX != None):
	env['CXX'] = CXX


# Set it to use timestamps to determine if a rebuild is neceesary, instead of MD5 hashes
env.SourceSignatures('timestamp')

env.StaticLibrary(target=BASENAME, source=sources)
